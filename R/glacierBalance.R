#' Calculate glacier mass balance of all glaciers in a basin over time.
#'
#' Small glaciers below area_threshold in km2 are treated as one unit whereas
#' large glaciers above area_threshold are treated in elevation bands.
#'
#' @param melt_a_eb Annual glacier melt in mm/a for each glacier/elevation band.
#'   The aggregation period is from October 1 of the previous year to September
#'   30 of the current year. The object \code{melt_a_eb} must contain the
#'   columns \code{Hyear} for the hydrological year, \code{ID} for the
#'   glacier ID in the RGI format and \code{Melt} with the glacier melt in mm/a.
#'   The column \code{ID} is generated by paste0(RGIId, "_", elvtn_b) in the
#'   input rgi_elbands.
#' @param rgi_elbands A shape file based on the Randolph Glacier Inventory but
#'   with the larger glaciers subdivided into elevation bands. The object
#'   \code{rgi_elbands} must contain the columns \code{RGIId}, \code{A_km2} with
#'   the area of the glaciers/elevation bands in km2, \code{thickness_m} with
#'   the thickness of the glaciers/elevation bands in m. We further need a
#'   column called \code{Area_tot_glacier_km2} with the area of the entire
#'   glacier within the catchment and a column \code{ID} which is consistent with
#'   the \code{ID} column in object \code{melt_a_eb}.
#' @param area_threshold Threshold area separating small and large glaciers in
#'   km2. The default is 1 km2. The threshold value must be consistent with the
#'   one used to generate the \code{rgi_elvands} object.
#' @return A tibble containing annual glacier melt,  imbalance ablation,
#'   glacier volume, glacier area.
#'
#' @details The input object \code{melt_a_eb} can be generated by aggregating the
#'   daily glacier melt obtained with the function \code{glacierMelt_TI()} to
#'   the hydrological year. The vignette \code{glaciers-02} demonstrates a use
#'   case for the function. \cr
#'   The function performs a simplified glacier mass balance on an annual time
#'   step \code{t} as follows:  \cr
#'     - Update the glacier area \code{A(t) = glacierArea_RGIF(V(t-1))} \cr
#'     - Calculate glacier discharge from glacier melt \code{Qgl(t) = M(t)*A(t)} \cr
#'     - Estimate the imbalance ablation from the glacier melt
#'       \code{QglImb(t) = glacierImbalAbl(M(t))} \cr
#'     - Update the glacier volume \code{V(t) = V(t-1) + QglImb(t)}
#' @note Known issues: \cr
#'   The function currently does not allow for one single large glacier. Make
#'   sure there are either more than one large glaciers in your input or none.
#' @export
#' @family glacier functions
#' @examples
#'
glacierBalance <- function(melt_a_eb, rgi_elbands, area_threshold = 1) {

  # Test if all needed columns are available in the input variables and throw
  # an error if not.
  if (!("Hyear" %in% colnames(melt_a_eb))) {
    cat("Error. Column Hyear not found in input melt_a_eb.\n")
    return(NULL)
  }
  if (!("ID" %in% colnames(melt_a_eb))) {
    cat("Error. Column ID not found in input melt_a_eb.\n")
    return(NULL)
  }
  if (!("Melt" %in% colnames(melt_a_eb))) {
    cat("Error. Column Melt not found in input melt_a_eb.\n")
    return(NULL)
  }

  if (!("ID" %in% colnames(rgi_elbands))) {
    cat("Error. Column ID not found in input rgi_elbands.\n")
    return(NULL)
  }
  if (!("Area_tot_glacier_km2" %in% colnames(rgi_elbands))) {
    cat("Error. Column Area_tot_glacier_km2 not found in input rgi_elbands.\n")
    return(NULL)
  }
  if (!("A_km2" %in% colnames(rgi_elbands))) {
    cat("Error. Column A_km2 not found in input rgi_elbands.\n")
    return(NULL)
  }
  if (!("thickness_m" %in% colnames(rgi_elbands))) {
    cat("Error. Column thickness_m not found in input rgi_elbands.\n")
    return(NULL)
  }


  # Calculate the initial volume of the glaciers & elevation bands
  if (sum(stringr::str_detect("sf", class(rgi_elbands))) > 0) {
    rgi_elbands <- rgi_elbands |>
      sf::st_drop_geometry()
  }
  rgi_elbands <- rgi_elbands |>
    dplyr::mutate(V_km3 = .data$A_km2 * .data$thickness_m*10^(-3))

  # Separate small glaciers from large ones
  rgi_small <- rgi_elbands |>
    dplyr::filter(.data$Area_tot_glacier_km2 < area_threshold)

  rgi_large <- rgi_elbands |>
    dplyr::filter(.data$Area_tot_glacier_km2 >= area_threshold)

  A_small <- rgi_small |>
    dplyr::select(.data$ID, .data$A_km2) |>
    tidyr::pivot_wider(names_from = .data$ID, values_from = .data$A_km2)

  A_large <- rgi_large |>
    dplyr::select(.data$ID, .data$A_km2) |>
    tidyr::pivot_wider(names_from = .data$ID, values_from = .data$A_km2)

  # The glacier mass balance is quite sensitive
  V_large <- rgi_large |>
    dplyr::mutate(Vtot_km3 = glacierVolume_RGIF(.data$Area_tot_glacier_km2)) |>
    dplyr::select(.data$ID, .data$Vtot_km3) |>
    tidyr::pivot_wider(names_from = .data$ID, values_from = .data$Vtot_km3)

  melt_small <- melt_a_eb |>
    dplyr::select(.data$Hyear, .data$ID, .data$Melt) |>
    dplyr::filter(.data$ID %in% rgi_small$ID) |>
    tidyr::pivot_wider(names_from = .data$ID, values_from = .data$Melt)

  melt_large <- melt_a_eb |>
    dplyr::select(.data$Hyear, .data$ID, .data$Melt) |>
    dplyr::filter(.data$ID %in% rgi_large$ID) |>
    tidyr::pivot_wider(names_from = .data$ID, values_from = .data$Melt)


  # Calculate glacier mass balance for small glaciers directly and for elevation
  # bands of large glaciers which are then accumulated.
  results_small <- stepWiseGlacierBalance(M_mma = melt_small,
                                          A_km2 = A_small |> as.matrix())

  results_large <- stepWiseGlacierBalancePerElBand(M_mma = melt_large,
                                                   A_km2 = A_large |>
                                                     as.matrix(),
                                                   V_km3 = V_large |>
                                                     as.matrix())


  # Return a tibble with the results
  Q_m3a <- cbind(results_small$Q_m3a, results_large$Q_m3a)
  V_km3 <- cbind(results_small$V_km3, results_large$V_km3)
  A_km2 <- cbind(results_small$A_km2, results_large$A_km2)
  Qimb_m3a <- cbind(results_small$Qimb_m3a, results_large$Qimb_m3a)
  dVdt_m3a <- rbind(rep(NA, dim(V_km3)[2]), diff(V_km3))*10^9

  Aelb_km2 <- cbind(results_small$A_km2, results_large$Aelb_km2) |>
    dplyr::as_tibble() |> dplyr::mutate(Hyear = unique(melt_a_eb$Hyear))

  # All other results are per glacier
  sim_hist <- Q_m3a |>
    dplyr::as_tibble() |> dplyr::mutate(Hyear = unique(melt_a_eb$Hyear)) |>
    tidyr::pivot_longer(-.data$Hyear, names_to = "RGIId", values_to = "Q_m3a") |>
    dplyr::mutate(Q_m3s = .data$Q_m3a/(60*60*24*365)) |>
    tibble::add_column(Qimb_m3a |>
                         dplyr::as_tibble() |>
                         dplyr::mutate(Hyear = unique(melt_a_eb$Hyear)) |>
                         tidyr::pivot_longer(-.data$Hyear, names_to = "RGIId",
                                             values_to = "Qimb_m3a") |>
                 dplyr::select(Qimb_m3a)) |>
    tibble::add_column(V_km3 |>
                         dplyr::as_tibble() |>
                         dplyr::mutate(Hyear = unique(melt_a_eb$Hyear)) |>
                         tidyr::pivot_longer(-.data$Hyear, names_to = "RGIId",
                                             values_to = "V_km3") |>
                         dplyr::select(V_km3)) |>
    tibble::add_column(dVdt_m3a |>
                         dplyr::as_tibble() |>
                         dplyr::mutate(Hyear = unique(melt_a_eb$Hyear)) |>
                         tidyr::pivot_longer(-.data$Hyear, names_to = "RGIId",
                                             values_to = "dVdt_m3a") |>
                         dplyr::select(dVdt_m3a)) |>
    tibble::add_column(A_km2 |>
                         dplyr::as_tibble() |>
                         dplyr::mutate(Hyear = unique(melt_a_eb$Hyear)) |>
                         tidyr::pivot_longer(-.data$Hyear, names_to = "RGIId",
                                             values_to = "A_km2") |>
                         dplyr::select(A_km2)) |>
    dplyr::mutate(RGIId = gsub("_\\d", "", .data$RGIId)) |>
    tidyr::pivot_longer(-c(.data$Hyear, .data$RGIId), names_to = "Variable",
                        values_to = "Value")

  # Remove the volume change computed around the reference time.
  sim_hist <- sim_hist |>
    dplyr::mutate(Value = ifelse(
      .data$Variable == "dVdt_m3a" & .data$Hyear %in% c(1999:2001),
      NA, .data$Value))

  return(sim_hist)

}




#' Glacier volume change over time for small glaciers < 1km2
#'
#' @param M_mma matrix with glacier melt rates in mm/a (in columns) per
#'   hydrological year (in rows). Also must contain a column named Hyear.
#' @param A_km2 matrix with glacier area in km2 (in columns) for the
#'   start year (the year 2000). Extracted from the geometries of the glaciers
#'   in the RGI v6.0 data set.
#' @return c(Q_m3a, V_km3, A_km2, Qimb_m3a) List of updated variables over the
#'   same time interval as M_mma. Q_m3a: glacier discharge, V_km3: glacier
#'   volume in water equivalents, A_km2: glacier area, Qimb_m3a: imbalance
#'   ablation (<0: glacier melt, >0: glacier increase)
stepWiseGlacierBalance <- function(M_mma, A_km2) {

  if (!("Hyear" %in% colnames(M_mma))) {
    cat("Error. Column Hyear not found in input M_mma.\n")
    return(NULL)
  }

  years <- M_mma$Hyear
  colnames(M_mma) <- gsub("_\\d", "", colnames(M_mma))
  colnames(A_km2) <- gsub("_\\d", "", colnames(A_km2))

  M_mma_hist_mat <- M_mma |>
    dplyr::filter(Hyear <= 2000) |>
    dplyr::select(-Hyear) |>
    as.matrix()

  M_mma_fut_mat <- M_mma |>
    dplyr::filter(Hyear >= 2000) |>
    dplyr::select(-Hyear) |>
    as.matrix()

  # Backward in time
  if (dim(M_mma_hist_mat)[1] > 1) {
    years_hist <- years[years <= 2000]
    # Initialize glacier discharge, area and volume
    A_km2_hist <- matrix(A_km2, nrow = length(years_hist),
                         ncol = length(A_km2), byrow = TRUE)
    colnames(A_km2_hist) <- colnames(A_km2)
    Q_m3a_hist <- M_mma_hist_mat*10^(-3)*A_km2_hist*10^6
    Qimb_m3a_hist <- glacierImbalAbl(M_mma_hist_mat)
    V_km3_hist <- glacierVolume_RGIF(A_km2_hist)
    # Step-wise glacier water balance
    for (time in c((length(years_hist)-1): 1)) {
      A_km2_hist[time, ] <- glacierArea_RGIF(V_km3_hist[time+1, ])
      Q_m3a_hist[time, ] <- M_mma_hist_mat[time, ]*10^(-3)*
        A_km2_hist[time, ]*10^6
      # Q_m3a_hist[time, ] <- apply(
      #   rbind(glacierTotalAbl(M_mma_hist_mat[time, ]),
      #         V_km3_hist[time-1, ] * 10^9),
      #   2, min)
      Qimb_m3a_hist[time, ] <- glacierImbalAbl(M_mma_hist_mat[time, ])
      Qimb_m3a_hist[time, ] <- ifelse(Qimb_m3a_hist[time,]< -Q_m3a_hist[time,],
                                      -Q_m3a_hist[time,], Qimb_m3a_hist[time,])
      V_km3_hist[time, ] <- V_km3_hist[time+1,] - Qimb_m3a_hist[time, ]*10^(-9)
    }
  }

  # Forward in time
  if (dim(M_mma_fut_mat)[1] > 1) {
    years_fut <- years[years >= 2000]
    # Initialize glacier discharge, area and volume
    A_km2_fut <- matrix(A_km2, nrow = length(years_fut),
                        ncol = length(A_km2), byrow = TRUE)
    colnames(A_km2_fut) <- colnames(A_km2)
    Q_m3a_fut <- M_mma_fut_mat*10^(-3)*A_km2_fut*10^6
    Qimb_m3a_fut <- glacierImbalAbl(M_mma_fut_mat)
    V_km3_fut <- glacierVolume_RGIF(A_km2_fut)
    # Step-wise glacier water balance
    for (time in c(2:length(years_fut))) {
      A_km2_fut[time, ] <- glacierArea_RGIF(V_km3_fut[time-1, ])
      # If the remaining glacier volume is smaller than the theoretical glacier
      # melt rate, apply the volume to the actual melt rate.
      Q_m3a_fut[time, ] <- apply(rbind(M_mma_fut_mat[time, ] * 10^(-3) *
                                         A_km2_fut[time, ] * 10^6,
                                       V_km3_fut[time-1, ] * 10^9), 2, min)
      # Q_m3a_fut[time, ] <- apply(rbind(glacierTotalAbl(M_mma_fut_mat[time, ]),
      #                                  V_km3_fut[time-1, ] * 10^9), 2, min)
      Qimb_m3a_fut[time, ] <- glacierImbalAbl(M_mma_fut_mat[time, ])
      Qimb_m3a_fut[time, ] <- ifelse(Qimb_m3a_fut[time, ] < -Q_m3a_fut[time, ],
                                     -Q_m3a_fut[time, ], Qimb_m3a_fut[time, ])
      V_km3_fut[time, ] <- apply(rbind(V_km3_fut[time-1,] + Qimb_m3a_fut[time, ]*10^(-9),
                                       V_km3_fut[time-1,]*0), 2, max)
    }
  }
  #browser()
  # Concatenate the produced time series
  if (dim(M_mma_hist_mat)[1] > 1) {
    if (dim(M_mma_fut_mat)[1] > 1) {
      # as.matrix ensures that the format is maintained.
      # A_km2 <- rbind(A_km2_hist, as.matrix(A_km2_fut[-1, ]))
      # V_km3 <- rbind(V_km3_hist, as.matrix(V_km3_fut[-1, ]))
      # Q_m3a <- rbind(Q_m3a_hist, as.matrix(Q_m3a_fut[-1, ]))
      # Get rid of hickups because of initial values
      A_km2 <- rbind(as.matrix(A_km2_hist[1:(length(years_hist)-1), ]),
                     colMeans(rbind(A_km2_hist[length(years_hist)-1, ]),
                              A_km2_fut[2, ]),
                     as.matrix(A_km2_fut[-1, ]))
      V_km3 <- rbind(as.matrix(V_km3_hist[1:(length(years_hist)-1), ]),
                     colMeans(rbind(V_km3_hist[length(years_hist)-1, ]),
                              V_km3_fut[2, ]),
                     as.matrix(V_km3_fut[-1, ]))
      Q_m3a <- rbind(as.matrix(Q_m3a_hist[1:(length(years_hist)-1), ]),
                     colMeans(rbind(Q_m3a_hist[length(years_hist)-1, ]),
                              Q_m3a_fut[2, ]),
                     as.matrix(Q_m3a_fut[-1, ]))
      Qimb_m3a <- rbind(as.matrix(Qimb_m3a_hist[1:(length(years_hist)-1), ]),
                        colMeans(rbind(Qimb_m3a_hist[length(years_hist)-1, ]),
                                 Qimb_m3a_fut[2, ]),
                        as.matrix(Qimb_m3a_fut[-1, ]))
    } else {
      A_km2 <- A_km2_hist
      V_km3 <- V_km3_hist
      Q_m3a <- Q_m3a_hist
      Qimb_m3a <- Qimb_m3a_hist
    }
  } else {
    if (dim(M_mma_fut_mat)[1] > 1) {
      A_km2 <- A_km2_fut
      V_km3 <- V_km3_fut
      Q_m3a <- Q_m3a_fut
      Qimb_m3a <- Qimb_m3a_fut
    } else {
      cat("Message: No large glaciers processed.\n")
      return(NULL)
    }
  }

  return(list("Q_m3a" = Q_m3a, "V_km3" = V_km3, "A_km2" = A_km2,
              "Qimb_m3a" = Qimb_m3a))

}




#' Glacier volume change over time
#'
#' @param M_mma matrix with glacier melt rates in mm/a (in columns) per
#'   hydrological year (in rows). Also must contain a column named Hyear.
#' @param A_km2 matrix with area of elevation bands in km2 (in columns) for
#'   the start year (the year 2000). Extracted from the geometries of the
#'   glaciers in the RGI v6.0 data set.
#' @param V_km3 matrix with volume of elevation bands in km3 (in columns) for
#'   the start year (year 2000). Area of elevation bands A_km2 times the
#'   mean thickness in the elevation bands extracted from Farinotti et al.
#' @return c(Q_m3a, V_km3, A_km2) List of updated variables over the same time
#'   interval as M_mma
stepWiseGlacierBalancePerElBand <- function(M_mma, A_km2, V_km3) {

  if (!("Hyear" %in% colnames(M_mma))) {
    cat("Error. Column Hyear not found in input M_mma.\n")
    return(NULL)
  }

  years <- M_mma$Hyear
  glaciers <- unique(gsub("_\\d", "",
                          colnames(M_mma |> dplyr::select(-Hyear))))

  M_mma_hist_mat <- M_mma |>
    dplyr::filter(Hyear <= 2000) |>
    dplyr::select(-Hyear) |>
    as.matrix()

  M_mma_fut_mat <- M_mma |>
    dplyr::filter(Hyear >= 2000) |>
    dplyr::select(-Hyear) |>
    as.matrix()


  # Backward in time
  if (dim(M_mma_hist_mat)[1] > 1) {
    years_hist <- years[years <= 2000]
    # Initialize glacier discharge, area and volume
    A_km2_hist <- matrix(A_km2, nrow = length(years_hist),
                         ncol = length(A_km2), byrow = TRUE)
    colnames(A_km2_hist) <- colnames(A_km2)
    V_km3_hist <- matrix(V_km3, nrow = length(years_hist),
                         ncol = length(V_km3), byrow = TRUE)
    colnames(V_km3_hist) <- colnames(V_km3)
    Q_m3a_hist <- M_mma_hist_mat*10^(-3)*A_km2_hist*10^6
    Qimb_m3a_hist <- glacierImbalAbl(M_mma_hist_mat)
    # Step-wise glacier water balance (for each elevation band per glacier)
    for (glacier in glaciers) {
      # Filter for the glacier
      selection <- stringr::str_detect(colnames(M_mma_hist_mat), glacier)
      NelBand <- sum(selection)  # Number of elevation bands
      M_elBand <- M_mma_hist_mat[, stringr::str_detect(colnames(M_mma_hist_mat),
                                              glacier)]
      A_elBand <- A_km2_hist[, stringr::str_detect(colnames(A_km2), glacier)]
      A_glacier <- rowSums(A_elBand)
      weights_eb <- A_elBand[1, ]/A_glacier[1]
      Q_elBand <- Q_m3a_hist[, selection]
      V_elBand <- V_km3_hist[, stringr::str_detect(colnames(V_km3), glacier)]
      V_glacier <- rowSums(V_elBand)
      Q_glacier <- rowSums(Q_elBand)
      Qimb_glacier <- as.matrix(glacierImbalAbl(rowSums(M_elBand)))
      for (time in c((length(years_hist)-1): 1)) {
        Q_elBand[time, ] <- M_elBand[time, ]*10^(-3)*
          A_elBand[time+1, ]*10^6
        Q_glacier[time] <- sum(Q_elBand[time, ])
        Qimb_glacier[time] <- glacierImbalAbl(sum(M_elBand[time, ]))
        Qimb_glacier[time] <- ifelse(Qimb_glacier[time] < -Q_glacier[time],
                                     -Q_glacier[time], Qimb_glacier[time])
        V_glacier[time] <- V_glacier[time+1] - Qimb_glacier[time]*10^(-9)
        A_glacier[time] <- glacierArea_RGIF(V_glacier[time])
        A_elBand[time, ] <- A_glacier[time]*weights_eb
      }
      if (glacier == glaciers[1]) {
        V_km3_hist_new <- V_glacier
        A_km2_hist_new <- A_glacier
        Aelb_km2_hist_new <- A_elBand
        Q_m3a_hist_new <- Q_glacier
        Qimb_m3a_hist_new <- Qimb_glacier
      } else {
        V_km3_hist_new <- cbind(V_km3_hist_new, V_glacier)
        A_km2_hist_new <- cbind(A_km2_hist_new, A_glacier)
        Aelb_km2_hist_new <- cbind(Aelb_km2_hist_new, A_elBand)
        Q_m3a_hist_new <- cbind(Q_m3a_hist_new, Q_glacier)
        Qimb_m3a_hist_new <- cbind(Qimb_m3a_hist_new, Qimb_glacier)
      }
    }
    colnames(V_km3_hist_new) <- glaciers
    colnames(A_km2_hist_new) <- glaciers
    colnames(Aelb_km2_hist_new) <- colnames(A_km2)
    colnames(Q_m3a_hist_new) <- glaciers
    colnames(Qimb_m3a_hist_new) <- glaciers
  }


  # Forward in time
  if (dim(M_mma_fut_mat)[1] > 1) {
    years_fut <- years[years >= 2000]
    # Initialize glacier discharge, area and volume
    A_km2_fut <- matrix(A_km2, nrow = length(years_fut),
                        ncol = length(A_km2), byrow = TRUE)
    colnames(A_km2_fut) <- colnames(A_km2)
    V_km3_fut <- matrix(V_km3, nrow = length(years_fut),
                        ncol = length(V_km3), byrow = TRUE)
    colnames(V_km3_fut) <- colnames(V_km3)
    Q_m3a_fut <- M_mma_fut_mat*10^(-3)*A_km2_fut*10^6
    # Step-wise glacier water balance (for each elevation band per glacier)
    for (glacier in glaciers) {
      # Filter for the glacier
      selection <- stringr::str_detect(colnames(M_mma_fut_mat), glacier)
      NelBand <- sum(selection)  # Number of elevation bands
      M_elBand <- M_mma_fut_mat[, stringr::str_detect(colnames(M_mma_fut_mat),
                                             glacier)]
      A_elBand <- A_km2_fut[, stringr::str_detect(colnames(A_km2), glacier)]
      A_glacier <- rowSums(A_elBand)
      weights_eb <- A_elBand[1, ]/A_glacier[1]
      Q_elBand <- Q_m3a_fut[, selection]
      V_elBand <- V_km3_fut[, stringr::str_detect(colnames(V_km3), glacier)]
      V_glacier <- rowSums(V_elBand)
      Q_glacier <- rowSums(Q_elBand)
      Qimb_glacier <- glacierImbalAbl(rowSums(M_elBand))
      for (time in c(2:length(years_fut))) {
        Q_elBand[time, ] <- M_elBand[time, ]*10^(-3)*
          A_elBand[time-1, ]*10^6
        # Limit glacier discharge by the remaining glacier volume.
        Q_glacier[time] <- apply(rbind(sum(Q_elBand[time, ]),
                                       V_glacier[time-1] * 10^9), 2, min)
        Qimb_glacier[time] <- glacierImbalAbl(sum(M_elBand[time, ]))
        Qimb_glacier[time] <- ifelse(Qimb_glacier[time] < -Q_glacier[time],
                                     -Q_glacier[time], Qimb_glacier[time])
        V_glacier[time] <- V_glacier[time-1] + Qimb_glacier[time]*10^(-9)
        A_glacier[time] <- glacierArea_RGIF(V_glacier[time])
        A_elBand[time, ] <- A_glacier[time]*weights_eb
      }
      if (glacier == glaciers[1]) {
        V_km3_fut_new <- V_glacier
        A_km2_fut_new <- A_glacier
        Aelb_km2_fut_new <- A_elBand
        Q_m3a_fut_new <- Q_glacier
        Qimb_m3a_fut_new <- Qimb_glacier
      } else {
        V_km3_fut_new <- cbind(V_km3_fut_new, V_glacier)
        A_km2_fut_new <- cbind(A_km2_fut_new, A_glacier)
        Aelb_km2_fut_new <- cbind(Aelb_km2_fut_new, A_elBand)
        Q_m3a_fut_new <- cbind(Q_m3a_fut_new, Q_glacier)
        Qimb_m3a_fut_new <- cbind(Qimb_m3a_fut_new, Qimb_glacier)
      }
    }
    colnames(V_km3_fut_new) <- glaciers
    colnames(A_km2_fut_new) <- glaciers
    colnames(Aelb_km2_fut_new) <- colnames(A_km2)
    colnames(Q_m3a_fut_new) <- glaciers
    colnames(Qimb_m3a_fut_new) <- glaciers
  }


  # Concatenate the produced time series
  if (dim(M_mma_hist_mat)[1] > 1) {
    if (dim(M_mma_fut_mat)[1] > 1) {
      # A_km2 <- rbind(A_km2_hist_new, as.matrix(A_km2_fut_new[-1, ]))
      # V_km3 <- rbind(V_km3_hist_new, as.matrix(V_km3_fut_new[-1, ]))
      # Q_m3a <- rbind(Q_m3a_hist_new, as.matrix(Q_m3a_fut_new[-1, ]))
      # Qimb_m3a <- rbind(Qimb_m3a_hist_new, as.matrix(Qimb_m3a_fut_new[-1, ]))
      A_km2 <- rbind(as.matrix(A_km2_hist_new[1:(length(years_hist)-1), ]),
                     colMeans(rbind(A_km2_hist_new[length(years_hist)-1, ]),
                              A_km2_fut_new[2, ]),
                     as.matrix(A_km2_fut_new[-1, ]))
      Aelb_km2 <- rbind(as.matrix(Aelb_km2_hist_new[1:(length(years_hist)-1), ]),
                        colMeans(rbind(Aelb_km2_hist_new[length(years_hist)-1, ]),
                                 Aelb_km2_fut_new[2, ]),
                        as.matrix(Aelb_km2_fut_new[-1, ]))
      V_km3 <- rbind(as.matrix(V_km3_hist_new[1:(length(years_hist)-1), ]),
                     colMeans(rbind(V_km3_hist_new[length(years_hist)-1, ]),
                              V_km3_fut_new[2, ]),
                     as.matrix(V_km3_fut_new[-1, ]))
      Q_m3a <- rbind(as.matrix(Q_m3a_hist_new[1:(length(years_hist)-2), ]),
                     rbind(colMeans(rbind(Q_m3a_hist_new[length(years_hist)-2, ]),
                                    Q_m3a_fut_new[3, ]),
                           colMeans(rbind(Q_m3a_hist_new[length(years_hist)-2, ]),
                                    Q_m3a_fut_new[3, ]),
                           colMeans(rbind(Q_m3a_hist_new[length(years_hist)-2, ]),
                                    Q_m3a_fut_new[3, ])),
                     as.matrix(Q_m3a_fut_new[3:length(years_fut), ]))
      Qimb_m3a <- rbind(as.matrix(Qimb_m3a_hist_new[1:(length(years_hist)-2), ]),
                        rbind(colMeans(rbind(Qimb_m3a_hist_new[length(years_hist)-2, ]),
                                       Qimb_m3a_fut_new[3, ]),
                              colMeans(rbind(Qimb_m3a_hist_new[length(years_hist)-2, ]),
                                       Qimb_m3a_fut_new[3, ]),
                              colMeans(rbind(Qimb_m3a_hist_new[length(years_hist)-2, ]),
                                       Qimb_m3a_fut_new[3, ])),
                        as.matrix(Qimb_m3a_fut_new[3:length(years_fut), ]))
    } else {
      A_km2 <- A_km2_hist_new
      Aelb_km2 <- Aelb_km2_hist_new
      V_km3 <- V_km3_hist_new
      Q_m3a <- Q_m3a_hist_new
      Qimb_m3a <- Qimb_m3a_hist_new
    }
  } else {
    if (dim(M_mma_fut_mat)[1] > 1) {
      A_km2 <- A_km2_fut_new
      Aelb_km2 <- Aelb_km2_fut_new
      V_km3 <- V_km3_fut_new
      Q_m3a <- Q_m3a_fut_new
      Qimb_m3a <- Qimb_m3a_fut_new
    } else {
      cat("Message: No small glaciers processed.\n")
      return(NULL)
    }
  }


  return(list("Q_m3a" = Q_m3a, "V_km3" = V_km3, "A_km2" = A_km2,
              "Qimb_m3a" = Qimb_m3a, "Aelb_km2" = Aelb_km2))

}
